---
layout: post
title: "Functional Implementation Patterns"
date: 2015-11-02 21:26:13 +0100
comments: true
categories: 
---

{% comment %}
# Template

## Name
### Introduction
### Alternative names
### Forces
### Example
#### Diff
#### Step by step
### Use when
### Do not use when
### Relates to
#### Points to
#### Points here

{% endcomment %}

# Collection of HOFs

{% comment %}

## Map

## Reduce, Inject

## Each

## Filter, Keep, Select

## Flatten

{% endcomment %}

## Select Attribute


```ruby
class Array
  def select_attribute attr
    self.map { |unit| unit[attr] }
  end
end
```

usage:

```ruby
[71] pry(main)> [
    {:element => 1, :even? => false},
    {:element => 2, :even? => true},
    {:element => 3, :even? => false}]
                                   .select_attribute :even?
=> [false, true, false]
```

# Collection of patterns

## Decorating a collection

### Introduction

You want to materialize properties from a collection

### Alternative names

  * Intermediary
  * Functional decorator
  * Collection Annotation (from [Wallingford's Roundabout](http://www.cs.uni.edu/~wallingf/patterns/recursion.html), especially [Interface procedure](http://www.cs.uni.edu/~wallingf/patterns/recursion.html#2))

### Example

```ruby
[62] pry(main)> [1,2,3]
                       .map { |x| 
                         {:element => x, :even? => x.even? } 
                       }
=> [{:element=>1, :even?=>false}, {:element=>2, :even?=>true}, {:element=>3, :even?=>false}]
```

### Extra

Naming the decoration

```ruby
[62] pry(main)> [1,2,3]
                       .map { |x| 
                         {:element => x, :even? => x.even? } 
                       }
=> [{:element=>1, :even?=>false}, {:element=>2, :even?=>true}, {:element=>3, :even?=>false}]
```

compare to

```ruby
[63] pry(main)> [1,2,3]
                       .map { |x| [x, x.even?] }
=> [[1, false], [2, true], [3, false]]
```

In the latter, you are expressing the how, not the what.


## Expand a HOF

You have a HOF that you want to split in several ones

### Example

Original:

```ruby
[5] pry(main)> [1,2,3]
                      .select {|x| x.even?}
=> [2]
```

Introduce an intermediary:

```ruby
[2] pry(main)> [1,2,3]
                      .map { |x| [x, x.even?] }
=> [[1, false], [2, true], [3, false]]
```

Then select all that match:

```ruby
[67] pry(main)> [1,2,3]
                       .map    { |x| [x, x.even?] }
                       .select { |x| x[1] }
                       .map    { |x| x.first }
=> [2]
```

## Compact HOF

### Introduction

You have several HOFs in a row: you decorate the collection, act on the decorated values, then use only part from the new aggregation.

### Example

#### Diff

```
- .map { |x| [x, 2 * x]}
- .sort_by { |f| f[1]}
- .map { |x| x.first}
+ .sort_by { |x| 2 * x}
```

```ruby
[48] pry(main)> [0, -2, 90, 1, 2, 0]
                                    .map     { |x| [x, -x] }
                                    .sort_by { |x| x[1] }
                                    .map     { |x| x[0] }
=> [90, 2, 1, 0, 0, -2]
```

replace it by:

```ruby
[49] pry(main)> [0, -2, 90, 1, 2, 0]
                                    .sort_by { |x| -x }
=> [90, 2, 1, 0, 0, -2]
```

### Do not use when

This pattern is not appropriate when you depend on (i.e., cannot discard) the data generated by the decoration.

Example:
   
```ruby
[50] pry(main)> [0, -2, 90, 1, 2, 0]
                                    .map     { |x| [x, -x] }
                                    .sort_by { |x| x[1] }
=> [[90, -90], [2, -2], [1, -1], [0, 0], [0, 0], [-2, 2]]
```